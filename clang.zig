const std = @import("std");

const Build = @import("build.zig");
const LazyPath = std.Build.LazyPath;
const LLVMExportedArtifacts = @import("llvm_zig.zig").LLVMExportedArtifacts;
const ConfigHeader = std.Build.Step.ConfigHeader;
const Compile = std.Build.Step.Compile;
const Context = Build.Context;
const sources = @import("clangd_sources.zig");

pub const ClangExportedArtifacts = struct {
    ast_lib: *Compile,
    ast_matchers_lib: *Compile,
    basic_lib: *Compile,
    format_lib: *Compile,
    lex_lib: *Compile,
    tooling_core_lib: *Compile,
    tooling_inclusions_lib: *Compile,
    tooling_dependency_scanning_lib: *Compile,
    driver_lib: *Compile,
    frontend_lib: *Compile,
    sema_lib: *Compile,
    index_lib: *Compile,
    serialization_lib: *Compile,
    tooling_lib: *Compile,
    tooling_syntax_lib: *Compile,
    tooling_inclusions_stdlib_lib: *Compile,
    rewrite_lib: *Compile,
    analysis_lib: *Compile,
    clang_tooling_transformer_lib: *Compile,

    basic_version_config_header: *ConfigHeader,
    version_inc: LazyPath,
    config_config_header: *ConfigHeader,
    tablegenerated_incs: LazyPath,
    phase2_tablegenerated_incs: LazyPath,

    main_include_dir: LazyPath,

    pub fn includeAll(clang: *const @This(), c: *Compile) void {
        // .Target doesnt matter- no linking
        Context.linkIncludeAndConfigureExportedType(@This(), clang, c, .Target, .LinkNone);
    }
};

fn compileSupportLib(ctx: *const Context, is_host: bool) *Compile {
    var out = addClangLibrary(ctx, "clangSupport", is_host);
    out.addCSourceFiles(.{
        .root = ctx.srcPath("clang/lib/Support"),
        .files = sources.clang_support_lib_cpp_files,
        .flags = ctx.dupeGlobalFlags(),
        .language = .cpp,
    });
    return out;
}

var clang_headers: ?[]*ConfigHeader = null;
var clang_include_paths: ?[]LazyPath = null;
var global_llvm: ?*const LLVMExportedArtifacts = null;

fn addClangIncludesAndConfigHeaders(c: *Compile) void {
    global_llvm.?.includeAll(c);
    Context.configAll(c, clang_headers.?);
    Context.includeAll(c, clang_include_paths.?);
}

fn addClangExecutable(ctx: *const Context, name: []const u8, is_host: bool) *Compile {
    const out = ctx.b.addExecutable(.{
        .name = name,
        .root_module = if (is_host) ctx.makeHostModule() else ctx.makeModule(),
    });
    addClangIncludesAndConfigHeaders(out);
    out.linkLibCpp();
    return out;
}

fn addClangLibrary(ctx: *const Context, name: []const u8, is_host: bool) *Compile {
    const out = ctx.b.addLibrary(.{
        .name = name,
        .root_module = if (is_host) ctx.makeHostModule() else ctx.makeModule(),
    });
    addClangIncludesAndConfigHeaders(out);
    out.linkLibCpp();
    return out;
}

/// Fills out all the fields in Context.targets that start with clang_*
/// Called from root build.zig
pub fn build(ctx: *const Context, llvm: *const LLVMExportedArtifacts) ClangExportedArtifacts {
    global_llvm = llvm;

    const basic_version_config_header = ctx.b.addConfigHeader(
        ctx.paths.clang.include.clang.basic.clang_basic_version_config_header.makeOptions(),
        .{
            .CLANG_VERSION = Build.version_string,
            .CLANG_VERSION_MAJOR = @as(i64, Build.version.major),
            .CLANG_VERSION_MINOR = @as(i64, Build.version.minor),
            .CLANG_VERSION_PATCHLEVEL = @as(i64, Build.version.patch),
            // from clang/CMakeLists.txt
            .MAX_CLANG_ABI_COMPAT_VERSION = @as(i64, Build.version.major),
        },
    );

    // NOTE: this is normally dynamically generated by the script
    // llvm/cmake/modules/GenerateVersionFromVCS.cmake and called from
    // clang/lib/Basic/CMakeLists.txt
    // but I do not care right now
    const vcs_version_inc_writefile = ctx.b.addWriteFile("VCSVersion.inc",
        \\#undef CLANG_REVISION
        \\#undef CLANG_REPOSITORY
        \\#undef LLVM_REVISION
        \\#undef LLVM_REPOSITORY
    );
    const version_inc = vcs_version_inc_writefile.getDirectory();

    if (!ctx.opts.clang_enable_static_analyzer and ctx.opts.clang_enable_arcmt) {
        @panic("Cannot disable static analyzer while enabling ARCMT or Z3");
    }

    const config_config_header = ctx.b.addConfigHeader(
        ctx.paths.clang.include.clang.config.config_config_header.makeOptions(),
        .{
            .BUG_REPORT_URL = Build.bug_report_url,
            .CLANG_DEFAULT_PIE_ON_LINUX = ctx.opts.clang_default_pie_on_linux,
            .CLANG_DEFAULT_LINKER = ctx.opts.clang_default_linker,
            .CLANG_DEFAULT_CXX_STDLIB = ctx.opts.clang_default_cxx_stdlib,
            .CLANG_DEFAULT_RTLIB = ctx.opts.clang_default_rtlib,
            .CLANG_DEFAULT_UNWINDLIB = ctx.opts.clang_default_unwindlib,
            .CLANG_DEFAULT_OBJCOPY = ctx.opts.clang_default_objcopy,
            .CLANG_DEFAULT_OPENMP_RUNTIME = ctx.opts.clang_default_openmp_runtime,
            .CLANG_SYSTEMZ_DEFAULT_ARCH = ctx.opts.clang_systemz_default_arch,
            .CLANG_INSTALL_LIBDIR_BASENAME = ctx.b.fmt("lib{s}", .{if (ctx.target.is_64_bit) "64" else ""}),
            .CLANG_RESOURCE_DIR = ctx.opts.clang_resource_dir,
            .C_INCLUDE_DIRS = ctx.opts.clang_c_include_dirs,
            .CLANG_CONFIG_FILE_SYSTEM_DIR = "", // TODO: how are these two dirs determined in original cmake?
            .CLANG_CONFIG_FILE_USER_DIR = "",
            .DEFAULT_SYSROOT = ctx.opts.default_sysroot,
            .GCC_INSTALL_PREFIX = ctx.opts.gcc_install_prefix,
            .CLANG_HAVE_LIBXML = ctx.opts.clang_enable_libxml2,
            .CLANG_HAVE_RLIMITS = Context.targetHasHeader(ctx.module_opts.target.?.result, .RLIMITS_H),
            .CLANG_HAVE_DLFCN_H = Context.targetHasHeader(ctx.module_opts.target.?.result, .DLFCN_H),
            .CLANG_HAVE_DLADDR = Context.targetHasSymbol(ctx.module_opts.target.?.result, .DLADDR),
            .HOST_LINK_VERSION = @as(i64, @intCast(ctx.opts.host_link_version)),
            .ENABLE_LINKER_BUILD_ID = ctx.opts.enable_linker_build_id,
            .ENABLE_X86_RELAX_RELOCATIONS = ctx.opts.enable_x86_relax_relocations,
            .PPC_LINUX_DEFAULT_IEEELONGDOUBLE = ctx.opts.ppc_linux_default_ieeelongdouble,
            .CLANG_ENABLE_ARCMT = ctx.opts.clang_enable_arcmt,
            .CLANG_ENABLE_OBJC_REWRITER = ctx.opts.clang_enable_arcmt,
            .CLANG_ENABLE_STATIC_ANALYZER = ctx.opts.clang_enable_static_analyzer,
            .CLANG_SPAWN_CC1 = ctx.opts.clang_spawn_cc1,
            .CLANG_ENABLE_CIR = ctx.opts.clang_enable_cir,
        },
    );

    var headers = [_]*ConfigHeader{
        basic_version_config_header,
        config_config_header,
    };
    clang_headers = &headers;
    var includes = [_]LazyPath{
        ctx.srcPath("clang/include"),
        version_inc,
    };
    clang_include_paths = &includes;

    // naming these with clang_* because names are shared with llvm
    const clang_host_component_support_lib = block: {
        const lib = compileSupportLib(ctx, true);
        // clang support also has llvm support and tablegen lib
        Context.linkAll(lib, &.{
            llvm.host_component_tablegen_lib,
            llvm.host_component_support_lib,
        });
        break :block lib;
    };

    const clang_support_lib = compileSupportLib(ctx, false);

    const clang_host_component_tblgen_exe = block: {
        const lib = addClangExecutable(ctx, "clang-tblgen", true);
        lib.addCSourceFiles(.{
            .files = sources.clang_tablegen_cpp_files,
            .root = ctx.clangUtil("TableGen"),
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.linkAll(lib, &.{
            clang_host_component_support_lib,
            llvm.host_component_support_lib,
        });
        break :block lib;
    };

    const writefile_step = ctx.b.addWriteFiles();
    const writefile_step_phase2 = ctx.b.addWriteFiles();

    // generate all the needed .inc files and copy them into the subdir
    for (ctx.clang_tablegen_files) |desc| {
        ctx.addTablegenOutputFileToWriteFileStep(writefile_step, clang_host_component_tblgen_exe, desc);
    }
    for (ctx.clang_phase2_tablegen_files) |desc| {
        ctx.addTablegenOutputFileToWriteFileStep(writefile_step_phase2, clang_host_component_tblgen_exe, desc);
    }
    const clang_tablegenerated_incs = writefile_step.getDirectory();
    const clang_phase2_tablegenerated_incs = writefile_step_phase2.getDirectory();

    const clang_basic_lib = block: {
        const lib = addClangLibrary(ctx, "clangBasic", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Basic"),
            .files = sources.clang_basic_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            ctx.clangLib("Basic"),
            clang_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        break :block lib;
    };

    const clang_api_notes_lib = block: {
        const lib = addClangLibrary(ctx, "clangAPINotes", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("APINotes"),
            .files = sources.clang_api_notes_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{clang_basic_lib});
        break :block lib;
    };

    const clang_lex_lib = block: {
        const lib = addClangLibrary(ctx, "clangLex", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Lex"),
            .files = sources.clang_lex_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{clang_basic_lib});
        break :block lib;
    };

    const clang_ast_lib = block: {
        const lib = addClangLibrary(ctx, "clangAST", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("AST"),
            .files = sources.clang_ast_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            clang_phase2_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_basic_lib,
            clang_lex_lib,
        });
        break :block lib;
    };

    const clang_tooling_inclusions_stdlib_lib = block: {
        const lib = addClangLibrary(ctx, "clangToolingInclusionsStdlib", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Tooling/Inclusions/Stdlib"),
            .files = sources.clang_tooling_inclusions_stdlib_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{clang_ast_lib});
        break :block lib;
    };

    const clang_edit_lib = block: {
        const lib = addClangLibrary(ctx, "clangEdit", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Edit"),
            .files = sources.clang_edit_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_ast_lib,
            clang_basic_lib,
            clang_lex_lib,
        });
        break :block lib;
    };

    const clang_ast_matchers_lib = block: {
        const lib = addClangLibrary(ctx, "clangASTMatchers", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("ASTMatchers"),
            .files = sources.clang_ast_matchers_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_ast_lib,
            clang_basic_lib,
            clang_lex_lib,
        });
        break :block lib;
    };

    const clang_analysis_lib = block: {
        const lib = addClangLibrary(ctx, "clangAnalysis", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Analysis"),
            .files = sources.clang_analysis_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_ast_lib,
            clang_ast_matchers_lib,
            clang_basic_lib,
            clang_lex_lib,
        });
        break :block lib;
    };

    const clang_sema_lib = block: {
        const lib = addClangLibrary(ctx, "clangSema", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Sema"),
            .files = sources.clang_sema_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            clang_phase2_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_api_notes_lib,
            clang_ast_lib,
            clang_analysis_lib,
            clang_basic_lib,
            clang_edit_lib,
            clang_lex_lib,
            clang_support_lib,
        });
        break :block lib;
    };

    const clang_serialization_lib = block: {
        const lib = addClangLibrary(ctx, "clangSerialization", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Serialization"),
            .files = sources.clang_serialization_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            clang_phase2_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_basic_lib,
            clang_ast_lib,
            clang_lex_lib,
            clang_sema_lib,
        });
        break :block lib;
    };

    const clang_parse_lib = block: {
        const lib = addClangLibrary(ctx, "clangParse", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Parse"),
            .files = sources.clang_parse_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            clang_phase2_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_basic_lib,
            clang_ast_lib,
            clang_lex_lib,
            clang_sema_lib,
        });
        break :block lib;
    };

    const clang_driver_lib = block: {
        const lib = addClangLibrary(ctx, "clangDriver", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Driver"),
            .files = sources.clang_driver_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            clang_phase2_tablegenerated_incs,
            llvm.tablegenerated_incs,
            ctx.clangLib("Driver"),
        });
        Context.linkAll(lib, &.{clang_basic_lib});
        break :block lib;
    };

    const clang_frontend_lib = block: {
        const lib = addClangLibrary(ctx, "clangFrontend", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Frontend"),
            .files = sources.clang_frontend_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            clang_phase2_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_api_notes_lib,
            clang_ast_lib,
            clang_basic_lib,
            clang_driver_lib,
            clang_edit_lib,
            clang_lex_lib,
            clang_parse_lib,
            clang_sema_lib,
            clang_serialization_lib,
        });
        break :block lib;
    };

    const clang_rewrite_lib = block: {
        const lib = addClangLibrary(ctx, "clangRewrite", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Rewrite"),
            .files = sources.clang_rewrite_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_basic_lib,
            clang_lex_lib,
        });
        break :block lib;
    };

    const clang_tooling_core_lib = block: {
        const lib = addClangLibrary(ctx, "clangToolingCore", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Tooling/Core"),
            .files = sources.clang_tooling_core_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_basic_lib,
            clang_lex_lib,
            clang_rewrite_lib,
        });
        break :block lib;
    };

    const clang_tooling_inclusions_lib = block: {
        const lib = addClangLibrary(ctx, "clangToolingInclusions", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Tooling/Inclusions"),
            .files = sources.clang_tooling_inclusions_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_basic_lib,
            clang_lex_lib,
            clang_tooling_core_lib,
        });
        break :block lib;
    };

    const clang_format_lib = block: {
        const lib = addClangLibrary(ctx, "clangFormat", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Format"),
            .files = sources.clang_format_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_basic_lib,
            clang_lex_lib,
            clang_tooling_core_lib,
            clang_tooling_inclusions_lib,
        });
        break :block lib;
    };

    const clang_index_lib = block: {
        const lib = addClangLibrary(ctx, "clangIndex", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Index"),
            .files = sources.clang_index_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            clang_phase2_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_ast_lib,
            clang_basic_lib,
            clang_format_lib,
            clang_frontend_lib,
            clang_lex_lib,
            clang_serialization_lib,
            clang_tooling_core_lib,
        });
        break :block lib;
    };

    const clang_tooling_syntax_lib = block: {
        const lib = addClangLibrary(ctx, "clangToolingSyntax", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Tooling/Syntax"),
            .files = sources.clang_tooling_syntax_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            clang_phase2_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_ast_lib,
            clang_basic_lib,
            clang_frontend_lib,
            clang_lex_lib,
            clang_tooling_core_lib,
        });
        break :block lib;
    };

    const clang_tooling_lib = block: {
        const lib = addClangLibrary(ctx, "clangTooling", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Tooling"),
            .files = sources.clang_tooling_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            clang_phase2_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_ast_lib,
            clang_ast_matchers_lib,
            clang_ast_lib,
            clang_ast_matchers_lib,
            clang_basic_lib,
            clang_driver_lib,
            clang_format_lib,
            clang_frontend_lib,
            clang_lex_lib,
            clang_rewrite_lib,
            clang_serialization_lib,
            clang_tooling_core_lib,
        });
        break :block lib;
    };

    const clang_tooling_dependency_scanning_lib = block: {
        const lib = addClangLibrary(ctx, "clangDependencyScanning", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Tooling/DependencyScanning"),
            .files = sources.clang_tooling_dependency_scanning_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            clang_phase2_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_ast_lib,
            clang_basic_lib,
            clang_driver_lib,
            clang_frontend_lib,
            clang_lex_lib,
            clang_serialization_lib,
            clang_tooling_lib,
        });
        break :block lib;
    };

    const clang_tooling_refactoring_lib = block: {
        const lib = addClangLibrary(ctx, "clangToolingRefactoring", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Tooling/Refactoring"),
            .files = sources.clang_tooling_refactoring_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            clang_phase2_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_ast_lib,
            clang_ast_matchers_lib,
            clang_basic_lib,
            clang_format_lib,
            clang_index_lib,
            clang_lex_lib,
            clang_rewrite_lib,
            clang_tooling_core_lib,
            llvm.support_lib,
        });
        break :block lib;
    };

    const clang_tooling_transformer_lib = block: {
        const lib = addClangLibrary(ctx, "clangToolingTransformer", false);
        lib.addCSourceFiles(.{
            .root = ctx.clangLib("Tooling/Transformer"),
            .files = sources.clang_tooling_transformer_lib_cpp_files,
            .flags = ctx.dupeGlobalFlags(),
            .language = .cpp,
        });
        Context.includeAll(lib, &.{
            clang_tablegenerated_incs,
            clang_phase2_tablegenerated_incs,
            llvm.tablegenerated_incs,
        });
        Context.linkAll(lib, &.{
            clang_ast_lib,
            clang_ast_matchers_lib,
            clang_basic_lib,
            clang_lex_lib,
            clang_tooling_core_lib,
            clang_tooling_refactoring_lib,
            llvm.support_lib,
            llvm.frontend_openmp_lib,
        });
        break :block lib;
    };

    return ClangExportedArtifacts{
        .ast_lib = clang_ast_lib,
        .ast_matchers_lib = clang_ast_matchers_lib,
        .basic_lib = clang_basic_lib,
        .format_lib = clang_format_lib,
        .lex_lib = clang_lex_lib,
        .tooling_core_lib = clang_tooling_core_lib,
        .tooling_inclusions_lib = clang_tooling_inclusions_lib,
        .tooling_dependency_scanning_lib = clang_tooling_dependency_scanning_lib,
        .driver_lib = clang_driver_lib,
        .frontend_lib = clang_frontend_lib,
        .sema_lib = clang_sema_lib,
        .index_lib = clang_index_lib,
        .serialization_lib = clang_serialization_lib,
        .tooling_lib = clang_tooling_lib,
        .tooling_syntax_lib = clang_tooling_syntax_lib,
        .tooling_inclusions_stdlib_lib = clang_tooling_inclusions_stdlib_lib,
        .rewrite_lib = clang_rewrite_lib,
        .analysis_lib = clang_analysis_lib,
        .clang_tooling_transformer_lib = clang_tooling_transformer_lib,

        .version_inc = version_inc,
        .config_config_header = config_config_header,
        .basic_version_config_header = basic_version_config_header,
        .tablegenerated_incs = clang_tablegenerated_incs,
        .phase2_tablegenerated_incs = clang_phase2_tablegenerated_incs,
        .main_include_dir = ctx.srcPath("clang/include"),
    };
}
